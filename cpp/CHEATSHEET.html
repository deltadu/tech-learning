<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Quick Reference</title>
    <style>
        /* Print-friendly styling */
        :root {
            --text-color: #1a1a1a;
            --bg-color: #ffffff;
            --code-bg: #f5f5f5;
            --border-color: #ddd;
            --link-color: #0066cc;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            font-size: 11pt;
            line-height: 1.6;
            color: var(--text-color);
            background: var(--bg-color);
            max-width: 8.5in;
            margin: 0 auto;
            padding: 0.5in;
        }
        
        h1 {
            font-size: 24pt;
            border-bottom: 2px solid var(--text-color);
            padding-bottom: 0.3em;
            margin-top: 0;
        }
        
        h2 {
            font-size: 18pt;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.2em;
            margin-top: 1.5em;
            page-break-after: avoid;
        }
        
        h3 {
            font-size: 14pt;
            margin-top: 1.2em;
            page-break-after: avoid;
        }
        
        h4 {
            font-size: 12pt;
            margin-top: 1em;
        }
        
        p {
            margin: 0.8em 0;
        }
        
        a {
            color: var(--link-color);
            text-decoration: none;
        }
        
        /* Code blocks */
        pre {
            background: var(--code-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 12px;
            overflow-x: auto;
            font-size: 9pt;
            line-height: 1.4;
            page-break-inside: avoid;
        }
        
        code {
            font-family: "SF Mono", "Consolas", "Monaco", monospace;
            font-size: 9pt;
        }
        
        p code, li code, td code {
            background: var(--code-bg);
            padding: 2px 5px;
            border-radius: 3px;
            border: 1px solid var(--border-color);
        }
        
        pre code {
            background: none;
            padding: 0;
            border: none;
        }
        
        /* Tables */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
            font-size: 10pt;
            page-break-inside: avoid;
        }
        
        th, td {
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            text-align: left;
        }
        
        th {
            background: var(--code-bg);
            font-weight: 600;
        }
        
        tr:nth-child(even) {
            background: #fafafa;
        }
        
        /* Lists */
        ul, ol {
            padding-left: 1.5em;
            margin: 0.5em 0;
        }
        
        li {
            margin: 0.3em 0;
        }
        
        /* Blockquotes */
        blockquote {
            border-left: 4px solid var(--border-color);
            margin: 1em 0;
            padding: 0.5em 1em;
            background: #fafafa;
        }
        
        /* Horizontal rule */
        hr {
            border: none;
            border-top: 1px solid var(--border-color);
            margin: 2em 0;
        }
        
        /* ASCII diagrams - preserve formatting */
        pre {
            white-space: pre;
            word-wrap: normal;
        }
        
        /* Print styles */
        @media print {
            body {
                padding: 0;
                font-size: 10pt;
            }
            
            pre {
                font-size: 8pt;
                border: 1px solid #999;
            }
            
            h1 {
                font-size: 20pt;
            }
            
            h2 {
                font-size: 16pt;
                page-break-after: avoid;
            }
            
            h3 {
                font-size: 13pt;
                page-break-after: avoid;
            }
            
            pre, table, blockquote {
                page-break-inside: avoid;
            }
            
            a {
                color: var(--text-color);
            }
            
            /* Avoid orphans */
            p, li {
                orphans: 3;
                widows: 3;
            }
        }
        
        /* Table of contents */
        .toc {
            background: var(--code-bg);
            padding: 1em;
            border-radius: 4px;
            margin: 1em 0;
        }
        
        .toc ul {
            list-style: none;
            padding-left: 1em;
        }
        
        .toc > ul {
            padding-left: 0;
        }
    </style>
</head>
<body>
<h1 id="c-quick-reference">C++ Quick Reference</h1>
<h2 id="compiling-running">Compiling &amp; Running</h2>
<div class="highlight"><pre><span></span><code><span class="c1"># Basic compile</span>
g++<span class="w"> </span>-o<span class="w"> </span>program<span class="w"> </span>program.cpp

<span class="c1"># With warnings (recommended)</span>
g++<span class="w"> </span>-Wall<span class="w"> </span>-o<span class="w"> </span>program<span class="w"> </span>program.cpp

<span class="c1"># With C++17 features</span>
g++<span class="w"> </span>-Wall<span class="w"> </span>-std<span class="o">=</span>c++17<span class="w"> </span>-o<span class="w"> </span>program<span class="w"> </span>program.cpp

<span class="c1"># Run</span>
./program
</code></pre></div>

<hr />
<h2 id="io-streams">I/O Streams</h2>
<table>
<thead>
<tr>
<th>Object</th>
<th>Meaning</th>
<th>Operator</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::cout</code></td>
<td>Output to screen</td>
<td><code>&lt;&lt;</code> (insertion)</td>
</tr>
<tr>
<td><code>std::cin</code></td>
<td>Input from keyboard</td>
<td><code>&gt;&gt;</code> (extraction)</td>
</tr>
<tr>
<td><code>std::endl</code></td>
<td>Newline + flush</td>
<td></td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">number</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cin</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="p">);</span><span class="w">  </span><span class="c1">// Read entire line with spaces</span>
</code></pre></div>

<hr />
<h2 id="vector-dynamic-array-list">Vector (Dynamic Array / List)</h2>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Operation</th>
<th>Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create empty</td>
<td><code>std::vector&lt;int&gt; v;</code></td>
</tr>
<tr>
<td>Create with values</td>
<td><code>std::vector&lt;int&gt; v = {1, 2, 3};</code></td>
</tr>
<tr>
<td>Create with size</td>
<td><code>std::vector&lt;int&gt; v(10);</code> (10 zeros)</td>
</tr>
<tr>
<td>Create with size &amp; value</td>
<td><code>std::vector&lt;int&gt; v(10, 5);</code> (10 fives)</td>
</tr>
<tr>
<td>Add to end</td>
<td><code>v.push_back(4);</code></td>
</tr>
<tr>
<td>Remove from end</td>
<td><code>v.pop_back();</code></td>
</tr>
<tr>
<td>Access by index</td>
<td><code>v[0]</code> or <code>v.at(0)</code></td>
</tr>
<tr>
<td>First element</td>
<td><code>v.front()</code></td>
</tr>
<tr>
<td>Last element</td>
<td><code>v.back()</code></td>
</tr>
<tr>
<td>Size</td>
<td><code>v.size()</code></td>
</tr>
<tr>
<td>Check empty</td>
<td><code>v.empty()</code></td>
</tr>
<tr>
<td>Clear all</td>
<td><code>v.clear()</code></td>
</tr>
<tr>
<td>Insert at index i</td>
<td><code>v.insert(v.begin() + i, value);</code></td>
</tr>
<tr>
<td>Erase at index i</td>
<td><code>v.erase(v.begin() + i);</code></td>
</tr>
</tbody>
</table>
<h3 id="iterating">Iterating</h3>
<div class="highlight"><pre><span></span><code><span class="c1">// Range-based (preferred)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// With index</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="c1">// By reference (to modify or avoid copy)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<hr />
<h2 id="2d-vector-matrix">2D Vector (Matrix)</h2>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Operation</th>
<th>Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create</td>
<td><code>std::vector&lt;std::vector&lt;int&gt;&gt; m = {{1,2}, {3,4}};</code></td>
</tr>
<tr>
<td>Create empty rows x cols</td>
<td><code>std::vector&lt;std::vector&lt;int&gt;&gt; m(rows, std::vector&lt;int&gt;(cols));</code></td>
</tr>
<tr>
<td>Create with default value</td>
<td><code>std::vector&lt;std::vector&lt;int&gt;&gt; m(rows, std::vector&lt;int&gt;(cols, val));</code></td>
</tr>
<tr>
<td>Access element</td>
<td><code>m[row][col]</code></td>
</tr>
<tr>
<td>Number of rows</td>
<td><code>m.size()</code></td>
</tr>
<tr>
<td>Number of cols in row i</td>
<td><code>m[i].size()</code></td>
</tr>
<tr>
<td>Add new row</td>
<td><code>m.push_back({5, 6, 7});</code></td>
</tr>
<tr>
<td>Add to existing row</td>
<td><code>m[0].push_back(99);</code></td>
</tr>
</tbody>
</table>
<h3 id="iterating_1">Iterating</h3>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">row</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<hr />
<h2 id="map-dictionary-hash-table">Map (Dictionary / Hash Table)</h2>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;map&gt;</span><span class="c1">           // Sorted by key, O(log n) lookup</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;unordered_map&gt;</span><span class="c1"> // Unsorted, O(1) average lookup</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Operation</th>
<th>Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create</td>
<td><code>std::map&lt;std::string, int&gt; m;</code></td>
</tr>
<tr>
<td>Insert/Update</td>
<td><code>m["key"] = value;</code></td>
</tr>
<tr>
<td>Insert (alternative)</td>
<td><code>m.insert({"key", value});</code></td>
</tr>
<tr>
<td>Access</td>
<td><code>m["key"]</code></td>
</tr>
<tr>
<td>Safe access (throws if missing)</td>
<td><code>m.at("key")</code></td>
</tr>
<tr>
<td>Check if key exists</td>
<td><code>m.count("key") &gt; 0</code></td>
</tr>
<tr>
<td>Check if key exists (alt)</td>
<td><code>m.find("key") != m.end()</code></td>
</tr>
<tr>
<td>Size</td>
<td><code>m.size()</code></td>
</tr>
<tr>
<td>Check empty</td>
<td><code>m.empty()</code></td>
</tr>
<tr>
<td>Erase by key</td>
<td><code>m.erase("key");</code></td>
</tr>
<tr>
<td>Clear all</td>
<td><code>m.clear()</code></td>
</tr>
</tbody>
</table>
<h3 id="iterating_2">Iterating</h3>
<div class="highlight"><pre><span></span><code><span class="c1">// C++17 structured bindings (preferred)</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="p">[</span><span class="n">key</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; -&gt; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Pre-C++17</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">pair</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; -&gt; &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="map-vs-unordered_map">map vs unordered_map</h3>
<table>
<thead>
<tr>
<th>Type</th>
<th>Order</th>
<th>Lookup</th>
<th>Use When</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>std::map</code></td>
<td>Sorted by key</td>
<td>O(log n)</td>
<td>Need sorted iteration</td>
</tr>
<tr>
<td><code>std::unordered_map</code></td>
<td>No order</td>
<td>O(1) avg</td>
<td>Need fast lookups</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="string-operations">String Operations</h2>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
</code></pre></div>

<table>
<thead>
<tr>
<th>Operation</th>
<th>Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Create</td>
<td><code>std::string s = "hello";</code></td>
</tr>
<tr>
<td>Length</td>
<td><code>s.length()</code> or <code>s.size()</code></td>
</tr>
<tr>
<td>Access char</td>
<td><code>s[0]</code> or <code>s.at(0)</code></td>
</tr>
<tr>
<td>Concatenate</td>
<td><code>s + " world"</code> or <code>s += " world"</code></td>
</tr>
<tr>
<td>Substring</td>
<td><code>s.substr(start, length)</code></td>
</tr>
<tr>
<td>Find</td>
<td><code>s.find("ell")</code> (returns index or <code>std::string::npos</code>)</td>
</tr>
<tr>
<td>Compare</td>
<td><code>s == "hello"</code> or <code>s.compare("hello")</code></td>
</tr>
<tr>
<td>Check empty</td>
<td><code>s.empty()</code></td>
</tr>
<tr>
<td>Clear</td>
<td><code>s.clear()</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="functions">Functions</h2>
<div class="highlight"><pre><span></span><code><span class="c1">// Declaration (prototype)</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">greet</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">);</span>

<span class="c1">// Definition</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">greet</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Hello, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Invocation</span>
<span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span>
<span class="n">greet</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">);</span>
</code></pre></div>

<hr />
<h2 id="references-vs-copies-rule-of-thumb">References vs Copies (Rule of Thumb)</h2>
<p>When iterating or passing to functions:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Recommendation</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Primitives (<code>int</code>, <code>double</code>, <code>char</code>, <code>bool</code>)</td>
<td>Copy</td>
<td><code>for (int x : nums)</code></td>
</tr>
<tr>
<td>Objects (<code>string</code>, <code>vector</code>, custom classes)</td>
<td><code>const</code> reference</td>
<td><code>for (const auto&amp; s : strings)</code></td>
</tr>
<tr>
<td>Need to modify</td>
<td>Non-const reference</td>
<td><code>for (int&amp; x : nums) { x *= 2; }</code></td>
</tr>
</tbody>
</table>
<p><strong>Why?</strong><br />
- Primitives are small (4-8 bytes) - copying is cheap<br />
- References add indirection overhead<br />
- Objects can be large - copying is expensive</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Primitives: just copy</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">numbers</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">values</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Objects: use const reference</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">row</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">matrix</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">names</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>

<span class="c1">// Function parameters follow the same rule</span>
<span class="kt">void</span><span class="w"> </span><span class="n">process</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">);</span><span class="w">                    </span><span class="c1">// Copy small primitives</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span><span class="w"> </span><span class="n">s</span><span class="p">);</span><span class="w">     </span><span class="c1">// Reference for objects</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">modify</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">);</span><span class="w">       </span><span class="c1">// Non-const ref to modify</span>
</code></pre></div>

<hr />
<h2 id="pointers-when-you-need-them">Pointers (When You Need Them)</h2>
<p>Modern C++ minimizes raw pointer usage. Here's when to use what:</p>
<h3 id="prefer-these-no-raw-pointers-needed">Prefer These (No Raw Pointers Needed)</h3>
<table>
<thead>
<tr>
<th>Situation</th>
<th>Use Instead</th>
</tr>
</thead>
<tbody>
<tr>
<td>Dynamic arrays</td>
<td><code>std::vector</code></td>
</tr>
<tr>
<td>Strings</td>
<td><code>std::string</code></td>
</tr>
<tr>
<td>Optional values</td>
<td><code>std::optional</code> (C++17)</td>
</tr>
<tr>
<td>Pass large objects</td>
<td><code>const T&amp;</code> reference</td>
</tr>
<tr>
<td>Modify in function</td>
<td><code>T&amp;</code> reference</td>
</tr>
</tbody>
</table>
<h3 id="when-you-still-need-pointers">When You Still Need Pointers</h3>
<table>
<thead>
<tr>
<th>Situation</th>
<th>Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td>Heap allocation with ownership</td>
<td><code>std::unique_ptr&lt;T&gt;</code></td>
</tr>
<tr>
<td>Shared ownership</td>
<td><code>std::shared_ptr&lt;T&gt;</code></td>
</tr>
<tr>
<td>Nullable reference</td>
<td><code>T*</code> (raw pointer)</td>
</tr>
<tr>
<td>Interfacing with C libraries</td>
<td><code>T*</code> (raw pointer)</td>
</tr>
</tbody>
</table>
<h3 id="smart-pointers-modern-c">Smart Pointers (Modern C++)</h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;memory&gt;</span>

<span class="c1">// unique_ptr: single owner, auto-deleted</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">p1</span><span class="p">;</span><span class="w">  </span><span class="c1">// 42</span>

<span class="c1">// shared_ptr: multiple owners, deleted when last owner gone</span>
<span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="k">auto</span><span class="w"> </span><span class="n">p3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p2</span><span class="p">;</span><span class="w">  </span><span class="c1">// Both point to same int</span>
</code></pre></div>

<h3 id="raw-pointers-when-necessary">Raw Pointers (When Necessary)</h3>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span><span class="w">      </span><span class="c1">// &amp; gets address</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span><span class="w">  </span><span class="c1">// * dereferences (prints 10)</span>
<span class="o">*</span><span class="n">ptr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w">          </span><span class="c1">// Modify through pointer</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w">     </span><span class="c1">// 20</span>

<span class="c1">// nullptr for &quot;points to nothing&quot;</span>
<span class="kt">int</span><span class="o">*</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">;</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="k">nullptr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>

<h3 id="summary-c-vs-c">Summary: C++ vs C</h3>
<table>
<thead>
<tr>
<th>C Style</th>
<th>Modern C++ Style</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>int* arr = malloc(...)</code></td>
<td><code>std::vector&lt;int&gt; arr</code></td>
</tr>
<tr>
<td><code>char* str = "hello"</code></td>
<td><code>std::string str = "hello"</code></td>
</tr>
<tr>
<td><code>free(ptr)</code></td>
<td>Automatic (RAII) or smart pointers</td>
</tr>
<tr>
<td><code>int* p = NULL</code></td>
<td><code>int* p = nullptr</code></td>
</tr>
</tbody>
</table>
<p><strong>Bottom line:</strong> In modern C++, you rarely need raw pointers. Use containers, references, and smart pointers instead.</p>
<hr />
<h2 id="useful-compiler-flags">Useful Compiler Flags</h2>
<table>
<thead>
<tr>
<th>Flag</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-Wall</code></td>
<td>Enable common warnings</td>
</tr>
<tr>
<td><code>-Wextra</code></td>
<td>Enable extra warnings</td>
</tr>
<tr>
<td><code>-std=c++17</code></td>
<td>Use C++17 standard</td>
</tr>
<tr>
<td><code>-std=c++20</code></td>
<td>Use C++20 standard</td>
</tr>
<tr>
<td><code>-O2</code></td>
<td>Optimize for speed</td>
</tr>
<tr>
<td><code>-g</code></td>
<td>Include debug symbols</td>
</tr>
</tbody>
</table>
</body>
</html>
